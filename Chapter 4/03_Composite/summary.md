# Composite

## 의도

- 객체를 트리 구조로 구성하여 부분-전체 계층을 나타내는 패턴
- 클라이언트는 개별 객체와 객체의 복합체를 동일하게 다룰 수 있음

## 동기

- 사용자는 하나의 객체나 객체의 모음을 동일하게 다루고자 하지만 단순한 코드 상으로는 객체와 객체의 모음이 다르게 다루어지는 경우가 존재
  - 객체를 재귀적으로 합성하여 클라이언트가 단일 객체와 복합 객체를 동일하게 다룰 수 있도록 함
- 별도의 추상화된 클래스를 도입하여 원시 객체와 이를 감싸는 컨테이너 객체를 모두 표현
  - 컨테이너 객체는 추상화된 클래스의 인터페이스를 다르기 때문에 다른 원시 객체나 컨테이너 객체를 재귀적으로 합성 가능함

## 활용성

- 객체들의 전체-부분 계층을 나타내고자 하는 경우 사용
- 클라이언트가 개별 객체와 복합 객체를 동일하게 다루고자 하는 경우 사용

## 구조

<img width="1065" alt="image" src="https://github.com/user-attachments/assets/ace833b6-ef37-4270-993a-912d655d0794" />

## 참여자

- Component
  - 객체의 복합에 사용할 인터페이스 정의
  - 모든 클래스에 공통적으로 적용되는 인터페이스 정의
  - 자식 컴포넌트에 접근하고 관리하는 인터페이스 정의
  - (Optional) 어떠한 컴포넌트의 부모 컴포넌트에 접근하는 인터페이스 정의
- Leaf
  - 복합 구조의 말단 객체로, 자식이 없는 원시 객체
  - 해당하는 객체의 메서드를 정의
- Composite
  - 자식을 가진 객체
  - 자신의 메서드를 정의
  - 자식 컴포넌트를 저장하고, 자식과 관련된 메서드를 정의
- Client
  - Component의 인터페이스를 사용하여 객체에 접근

## 협력 방식

- Client는 Component 클래스의 인터페이스를 사용하여 복합 구조 내의 객체와 상호작용을 수행

## 결과

### 장점

- 클라이언트 코드는 복합 객체와 원시 객체를 동일하게 취급 가능
- 새로운 컴포넌트를 구조에 추가하기 용이

### 단점

- 특정 상황에서만 컴포넌트나 메서드를 사용하도록 제약을 가할 수 없으며, 런타임에 체크해야 함

## 구현

- 자식이 부모를 참조하도록 구성하여 복합 구조의 관리 및 순회를 단순화시킬 수 있음
  - Composite 클래스의 Add, Remove 메서드에서만 자식의 부모를 설정하여 참조의 불변성을 지킬 수 있음
- 컴포넌트를 공유하도록 구현 가능
- Client가 Leaf나 Composite 객체를 동일하게 취급하도록 하기 위해 Component 인터페이스에 최대한 많은 공통 인터페이스를 정의해야 함
  - Leaf, Composite 클래스는 필요한 경우 해당 메서드를 override할 수 있음
- 자식을 순서대로 순회하는 요구 사항이 있는 경우 Iterator 패턴을 적용할 수 있음
