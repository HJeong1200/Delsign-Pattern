# Chain of Responsibility

## 의도

- 하나 이상의 객체에게 요청을 다룰 기회를 제공하여 요청 발신자와 수신자의 결합을 방지
- 여러 객체를 연쇄적으로 묶어서 요청이 특정 객체에 의해 처리될 때까지 전달

## 동기

- 특정한 요청을 처리하는 컴포넌트는 요청을 보내는 컴포넌트에게 명시적으로 연동되어 있지 않음
- 여러 객체를 연쇄적으로 묶음으로써 필요한 경우 하나의 객체가 요청을 처리하고, 필요하지 않은 경우 다른 객체에게 요청을 넘길 수 있도록 함
- 최초로 요청을 보내는 컴포넌트는 어떤 객체가 해당 요청을 처리하게 될지 알지 못함
- 요청을 체인 내의 다른 객체에게 전달하기 위해 각각의 객체는 요청을 처리하거나 다음 객체에 접근할 수 있는 공통의 인터페이스를 가져야 함

## 활용성

- 하나 이상의 객체가 요청을 처리할 수 있으며, 어떤 객체가 처리하는지의 여부를 미리 알지 못하는 경우
- 요청을 처리할 객체를 직접적으로 명시하지 않으면서 여러 객체 중 하나에게 요청을 보내고자 하는 경우
- 요청을 처리할 수 있는 객체들이 동적으로 정해지는 경우

## 구조

TODO: Add Image

## 참여자

- Handler
  - 요청을 처리하는 인터페이스 정의
  - 뒤따르는 객체에 대한 링크 구현
- ConcreteHandler
  - 필요한 경우 요청을 처리하고, 처리할 수 없는 경우 다른 객체에게 전달
  - 뒤따르는 객체에 접근
- Client
  - 요청을 ConcreteHandler에게 전달

## 협력 방식

- Client가 요청을 생성하고, 요청이 처리될 떄까지 ConcreteHandler 객체의 체인을 통해 전달

## 결과

### 장점

- 결합도 감소
  - 요청을 보내는 컴포넌트와 받는 컴포넌트는 서로를 명시적으로 인지하지 않아도 되며, 체인 내부의 객체는 체인 전체의 구조에 대해 인지하지 않아도 됨
  - 각각의 객체의 입장에서 요청이 적절하게 처리되기만 하면 됨
- 객체의 책임 부여 시 유연성 증가
  - 체인 내부에 객체를 추가하거나 체인 구조를 변경함으로써 책임을 추가할 수 있음

### 단점

- 요청의 처리를 보장할 수 없음
  - 요청의 명시적인 수신자가 없기 때문에 요청이 처리될 것이라고 보장할 수 없음

## 구현

- Handler가 새로운 링크를 만들거나 기존의 링크를 활용하는 방식으로 체인 생성
  - Composite, part-whole 구조 등은 부모에 대한 참조가 이미 존재함
- 체인 연결
  - 체인의 관계를 새로 생성하는 경우 핸들러는 request에 대한 처리 뿐만 아니라 연결되는 객체 또한 포함하도록 구성
- 요청의 구조
  - 객체, 함수 등을 사용 가능
