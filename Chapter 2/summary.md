# 2. A Case Study: Designing a Document Editor

## 문제를 해결하는 순서

1. 기능 및 목표 정의
2. 제약 분석
3. 사용 가능한 디자인 패턴 분석
4. 구체적인 해법 제안 및 적용

## Issue 1. 문서 구조

### 기능 및 목표 정의

- 문서의 물리적 구조를 유지하는 기능
  - 문자, 그래픽, 행, 열, 테이블 등의 정렬
- 문서를 시각적으로 생성하고 표현하는 기능
- 내부 표현 영역의 요소 및 화면에 표시된 요소를 대응하는 기능
  - 사용자가 특정 요소를 선택 시 내부 로직 상 어떠한 요소를 가리키고 있는지 파악

### 제약 분석

- 문자와 그래픽을 동일하게 다뤄야 함
  - 서식을 맞추거나 조작 기법을 한 번만 정의해서 문자와 그래픽 모두를 처리할 수 있어야 함
- 단일 요소와 그룹 요소를 구분해서 구현하면 안됨
- 철자법 검사와 붙임표 연결 지점 등의 처리를 위한 텍스트 분석 필요
  - 2번 제약 사항에 반대되는 제약
  - 어떠한 경우에는 모든 요소들을 서로 동일하게 다루어야 하며 어떠한 경우에는 구분해서 처리해야 함

### 사용 가능한 디자인 패턴 분석

- Composite pattern
  - 재귀적 합성을 통해 복잡한 계층적 구조 표현 가능

### 구체적인 해법 제안 및 적용

- 재귀적 합성 (Recursive composition)
  - 간단한 요소를 합성하여 복합적인 요소를 만드는 방법
  - 시각적 요소 (글자, 그래픽) 및 구조적 요소 (행, 열) 등을 각각 하나의 객체로 표현
  - 각각의 객체를 재귀적으로 합성하여 구조 형성
  <img width="646" alt="image" src="https://github.com/user-attachments/assets/63f643b6-7539-4b78-8312-632966e15d17" />
  
- 글리프 (Glyph)
  - 화면에 표시되는 구성 요소를 포괄적으로 일컫는 개념
  - 모든 객체를 위한 추상 클래스
    - 글리프의 서브클래스는 기본적인 시각적 요소와 구조적 요소를 정의
  <img width="645" alt="image" src="https://github.com/user-attachments/assets/10cc8b33-1146-4efb-9cf6-b28793fb2ca7" />
  
  - 글리프의 책임
    - 자신을 그리는 방법 정의
    - 자신이 차지하는 영역을 확인하는 방법 정의
    - 자신의 자식과 부모를 참조
  - 글리프의 기본 인터페이스
    | **책임** | **연산** | **설명** |
    | ----- | ----- | ----- |
    | 외형 | Draw | 자신을 그리는 방법 |
    | | Bounds | 자신이 차지하는 영역 반환 |
    | 선택 파악 | Intersects | 사용자가 선택한 지점이 자신과 교차하는지 여부 검증 |
    | 구조 | Insert | 자식 삽입 |
    | | Remove | 자식 제거 |
    | | Child | 사용자가 지정한 위치에 있는 자식이 존재하는 경우 반환 |
    | | Parent | 부모의 참조값 반환 |

## Issue 2. 서식 설정

### 기능 및 목표 정의

- 문서의 서식을 설정하는 기능
  - 문서의 물리적 구조를 저장하는 능력이 서식에 맞는 특정 구조를 만드는지의 여부를 알려주지 않음
- 글리프 집합을 라인으로 분해하는 기능

### 제약 분석

- 서식 설정의 품질과 서식 설정에 필요한 속도의 균형
- 문서 구조에 독립적인 알고리즘
  - 서식 설정 알고리즘에 상관없이 새로운 Glyph 클래스의 서브클래스를 추가할 수 있어야 함
  - 새로운 서식 설정 알고리즘을 추가할 때 기존의 Glyph 클래스가 변경되어선 안됨

### 사용 가능한 디자인 패턴 분석

- Strategy pattern
  - 알고리즘을 객체로 캡슐화
    - Strategy 패턴을 구현한 객체, 이 객체가 동작할 동작 환경으로 구성
  - 전략과 동작 환경에 대한 인터페이스의 일반화가 중요함
    - 새로운 알고리즘을 지원하기 위해 전략이나 동작 환경을 변경하지 않아야 함

### 구체적인 해법 제안 및 적용

- Compositor & Composition
  - Compositor 클래스는 서식 설정 알고리즘을 캡슐화하는 객체
  - Composition 클래스는 Glyph 클래스의 서브클래스이며 서식 설정이 필요할 때 Compositor 클래스에게 서식을 지정하도록 함
- Compositor 클래스
  - 인터페이스
    - 서식을 지정할 글리프가 무엇인지 확인하는 메서드
    - 서식 설정을 언제 하는지 확인하는 메서드
- Composition 클래스
  - 서식 설정 시 Compositor 객체의 메서드를 호출하여 자신을 가지고 있는 Glyph에 서식 지정

## Issue 3. 사용자 인터페이스 꾸미기

### 기능 및 목표 정의

- 텍스트의 페이지를 분리하기 위한 텍스트 편집 영역 주변의 테두리 (Border)
- 페이지의 서로 다른 부분을 볼 수 있도록 하는 스크롤바 (Scroll)

### 제약 분석

- 다른 클래스의 변경 없이 장식 요소를 추가하고 삭제할 수 있어야 함
  - 다른 사용자 인터페이스는 장식 요소가 있을지도 모른다는 가정 아래 설계 필요

### 사용 가능한 디자인 패턴 분석

- Decorator pattern
  - 객체에 책임을 추가하는 패턴

### 구체적인 해법 제안 및 적용

- 상속 vs 합성
  - 상속
    - 기존 클래스에서 장식 요소를 포함한 클래스를 확장하는 방식
    - 장식의 종류가 늘어날 때마다 새로운 클래스가 추가되어야 함
  - 합성
    - 장식을 하나의 객체로 만들고 기존 Glyph 클래스를 합성
- 투명한 포함
  - Border 클래스를 Glyph 클래스의 서브클래스로 생성
    - Border의 인터페이스와 Glyph의 인터페이스는 일치해야 함
  - 장식과 관련된 클래스는 Composition 클래스와 별개로 작동해야 함

## Issue 4. 다양한 룩앤필 표준 지원

### 기능 및 목표 정의

- 다양한 운영체제에 대응하는 사용자 인터페이스 스타일 표준 지원
- 새로운 표준이 추가되는 경우 이를 지원
- 런타임에 스타일 변경이 가능한 유연한 설계 구축

### 제약 분석

- 각 운영체제에 대응하는 스타일
- 런타임에 유저가 직접 스타일을 변경 가능해야 함

### 사용 가능한 디자인 패턴 분석

- Abstract Factory pattern
  - 클래스의 인스턴스를 직접 만들지 않고서도 관련된 제품 객체 군을 생성하는 방법 정의
    - 제품 객체의 종류는 일정하고 각 객체의 특성이 특정 제품군마다 차이를 보일 때 사용
  - 구체적인 팩토리를 지정하여 이를 통해서 제품을 생성하며, 동일 계열의 제품군을 다룰 수 있음

### 구체적인 해법 제안 및 적용

- 사용자 인터페이스의 위젯 요소 구분
  - 위젯의 각 카테고리별로 Glyph 클래스를 상속받는 서브클래스 집합
    - 기존 Glyph 인터페이스에 연산을 추가하여 확장한 추상 클래스
    - 예시: Scrollbar 클래스, Button 클래스 등
  - 각 추상 클래스를 상속하여 서로 다른 룩앤필을 구현하는 서브클래스 집합
    - Scrollbar 클래스를 각 운영체제 혹은 스타일 별로 상속
    - 예시: WindowScrollbar 클래스, MacScrollbar 클래스 등
  - 객체를 생성하는 과정 자체를 추상화
    - 명시적인 생성자 호출을 피함
    - 전체 위젯을 쉽게 변경 가능하도록 함
  - Factory class & Product class
    - GuiFactory를 통해 모든 종류의 룩앤필 표준을 지원하는 위젯 생성
      - GuiFactory는 위젯을 만드는 데 필요한 공통의 인터페이스를 정의하는 추상 클래스
    - GuiFactory의 서브클래스로 다양한 스타일을 만드는 제품 클래스 생성
      - MacFactory, WindowsFactory, LinuxFactory 등
      - 각각의 서브클래스는 GuiFactory의 연산을 구현하여 특정 룩앤필을 만족하는 위젯 반환
      <img width="645" alt="image" src="https://github.com/user-attachments/assets/4470bb61-0961-4703-b58a-da44dbd3a2e8" />


## Issue 5. 다중 윈도우 시스템 지원

### 기능 및 목표 정의

- 룩앤필 외의 기능에 대한 다양한 운영체제 지원

### 제약 분석

- 운영체제의 경우 각 시스템 별로 호환 가능성이 보장되지 않는 여러 클래스 계층이 존재하기 때문에 하나의 추상 클래스에서 구체적인 제품 클래스를 정의할 수 없음
- 운영체제의 인터페이스 별로 하는 일은 비슷하지만 구현하는 방법이 다름

### 사용 가능한 디자인 패턴 분석

- Bridge pattern
  - 서로 독립적으로 확장되지만 함께 동작해야 하는 개념을 별도의 클래스 계층으로 분리하는 것이 목적

### 구체적인 해법 제안 및 적용

- OS가 하는 일 (OS의 인터페이스)에 대한 추상화와 이를 구현하는 방법 (시스템이 제공하는 프로그래밍 인터페이스)의 추상화를 분리
  - 서로 다른 윈도우 시스템에서 공통적으로 수행하는 액션을 캡슐화하는 Window 클래스 구현
    - Window 클래스는 어떤 특정 OS에 종속되는 개념이 아니며 각 시스템에서 수행할 액션을 추상화한 객체
    - 예시: 기본적인 도현을 그리는 연산, 도형 및 그림 크기 변경, 콘텐츠 그리기
  - 서로 다른 윈도우 시스템 별로 다른 방식으로 수행하는 액션을 캡슐화하는 WindowImp 클래스 구현
    - WindowImp 클래스는 각 시스템 인터페이스에 따른 가변성을 동일한 인터페이스로 숨기기 때문에 윈도우 시스템의 세부 사항까지 신경쓸 필요가 없어짐

## Issue 6. 사용자 조작

### 기능 및 목표 정의

- 사용자 조작에 대한 지원
  - 새로운 문서 생성 및 기존 문서 열기, 저장, 출력
  - 텍스트 및 텍스트 스타일 편집
  - 응용 프로그램 종료

### 제약 분석

- 사용자 조작을 특정 사용자 인터페이스에 국한해서는 안됨
- 조작 기능은 여러 클래스에서 구현되기 때문에 구현자 쪽에서 조작을 위해 구현과 사용자 인터페이스 간 종속성을 만들어서는 안됨
- 일부 기능에 undo / redo 기능 추가 필요

### 사용 가능한 디자인 패턴 분석

- Command pattern
  - 요청을 발생시키는 데 필요한 균일한 인터페이스를 추상 클래스로 규정
    - 사용하는 컴포넌트 측면에서 서로 다른 요청을 동일하게 처리 가능

### 구체적인 해법 제안 및 적용

- 각각의 요청을 명령 (command) 객체 안에 캡슐화
  - Command 추상 클래스에서 요청을 발생시키는 execute 추상 연산 정의
  - Command 클래스의 서브클래스는 요청 수행을 위해 서로 다른 방식으로 execute 연산 구현
  - 각 메뉴 항목 객체는 해당 객체에 맞는 Command 객체를 저장하고 호출 시 execute 연산을 호출하여 필요한 연산 수행 가능
  <img width="674" alt="image" src="https://github.com/user-attachments/assets/69ecdfd7-d9ee-49fe-bba2-97bf4b7effdd" />

- Undo / redo 지원 위해 명령 이력 리스트 관리

## Issue 7. 철자 검사와 붙임표 처리

### 기능 및 목표 정의

- 텍스트 분석
  - 예시: 철자 검사, 붙임표 삽입, 탐색, 단어 개수 세기 등

### 제약 분석

- 추가적인 텍스트 분석 기능 확장이 가능해야 함
- 서로 다른 데이터 구조 (리스트, 배열 등)을 포괄할 수 있어야 하며 서로 다른 순회 방법을 지원해야 함

### 사용 가능한 디자인 패턴 분석

- Iterator pattern
  - 순회 알고리즘을 추상화하여 사용자가 순회하는 객체의 내부 표현 구조를 알 필요가 없도록 하는 패턴
- Visitor pattern
  - 방문하는 클래스에 대한 변경이 없이 해당 클래스에 어떠한 액션 수행 능력을 추가하는 패턴

### 구체적인 해법 제안 및 적용

- Iterator 클래스
  - 다양한 접근과 순회 방법을 일반화해서 정의
- Visitor 클래스
  - 구조를 순회하는 액션과 분석하는 액션을 분리
  - Visitor 클래스를 통해 각각의 Glyph 객체를 방문하여 객체의 형태에 따른 적절한 액션 수행
